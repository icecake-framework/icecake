package html

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"sort"
	"strconv"
	"strings"

	"github.com/icecake-framework/icecake/internal/helper"
	"github.com/icecake-framework/icecake/pkg/registry"
)

// HTMLSnippet enables creation of simple or complex html string based on
// an original templating system allowing embedding of other snippets.
// HTMLSnippet output is an html element:
//
//	<tagname [attributes]>[body]</tagname>
//
// It is common to embed a HTMLSnippet into a struct to define an html component.
type HTMLSnippet struct {
	tag       Tag // optional TagName
	body      HTMLString
	attrs     map[string]string // map of all attributes of any type
	embedded  map[string]any    // instantiated embedded objects
	dataState *DataState
}

// Ensure HTMLSnippet implements HTMLComposer interface
var _ HTMLComposer = (*HTMLSnippet)(nil)

func NewSnippet(tag Tag, attributes string, body HTMLString) *HTMLSnippet {
	snippet := new(HTMLSnippet)
	snippet.tag = tag
	ParseAttributes(attributes, snippet)
	snippet.body = body
	return snippet
}

func (_snippet *HTMLSnippet) SetDataState(ds *DataState) {
	_snippet.dataState = ds
}

func (_snippet *HTMLSnippet) Id() string {
	_snippet.makemap()
	id := _snippet.attrs["01id"]
	return id
}

// makemap ensure good memory allocation of the map of attributes
func (_snippet *HTMLSnippet) makemap() {
	if _snippet.attrs == nil {
		_snippet.attrs = make(map[string]string)
	}
}

// SetId sets or overwrites the id attribute of the html snippet
// if id is empty, the id attribute is removed
func (_snippet *HTMLSnippet) SetId(id string) {
	_snippet.makemap()
	if _, found := _snippet.attrs["01id"]; found {
		delete(_snippet.attrs, "01id")
	} else {
		_snippet.attrs["01id"] = id
	}
}

// SetUniqueId sets or overwrites the id attribute of the html snippet
// generating a unique id starting with the prefix.
// "ick-" is used to prefix the returned id if prefix is empty.
func (_snippet *HTMLSnippet) SetUniqueId(prefix string) {
	_snippet.makemap()
	_snippet.attrs["01id"] = registry.GetUniqueId(prefix)
}

// Tag returns the tag used to render the html element of the HTMLSnippet.
// If it's empty only the body will be rendered and all attributes will be ignored.
func (_snippet *HTMLSnippet) Tag() Tag {
	return _snippet.tag
}

// SetTag setup the Tag of the Snippet
// The HTMLComposer is returned allowing call chaining.
func (_snippet *HTMLSnippet) SetTag(tag Tag) {
	_snippet.tag = tag
}

// BodyTemplate returns the HTML template to unfold inside the html element of the HTMLComposer.
// func (_snippet *HTMLSnippet) BodyTemplate() HTMLString {
// 	return _snippet.bodytemplate
// }

// SetBodyTemplates sets the HTML template to unfold inside the html element of the HTMLComposer.
// The HTMLComposer is returned allowing call chaining.
// func (_snippet *HTMLSnippet) SetBodyTemplate(_body HTMLString) HTMLComposer {
// 	_snippet.bodytemplate = _body
// 	return _snippet
// }

// WriteBody writes the HTML string corresponing to the body of the HTML element
// Default Snippet unfolds body property if an, and write it.
// Can be overloaded by a custom snippet embedding HTMLSnippet.
func (_parent HTMLSnippet) WriteBody(out io.Writer) {
	io.WriteString(out, string(_parent.body))
}

// Embedded returns the map of embedded components, keyed by their id.
func (_parent HTMLSnippet) Embedded() map[string]any {
	return _parent.embedded
}

// Embed adds subcmp to the map of embedded components within the _parent.
// If a component with the same _id has already been embedded it's replaced.
// Usually the _id is the id of the html element.
func (parent *HTMLSnippet) Embed(id string, subcmp HTMLComposer) {
	strid := helper.Normalize(id)
	if parent.embedded == nil {
		parent.embedded = make(map[string]any, 1)
	}
	parent.embedded[strid] = subcmp
	// DEBUG: fmt.Printf("embedding %q(%v) into %s\n", id, reflect.TypeOf(cmp).String(), s.Id())
}

// String renders and unfold the _snippet and returns its corresponding HTML string
func (_snippet *HTMLSnippet) String() HTMLString {
	out := new(bytes.Buffer)
	_, err := WriteSnippet(out, _snippet, nil, true)
	if err != nil {
		return ""
	}
	return HTMLString(out.String())
}

// RenderChildSnippet builds and unfolds the childsnippet and returns its html string.
// The _snippet is embedded into the _parent.
// RenderChildSnippet does not mount the component into the DOM and so it can't respond to events.
// func (_parent *HTMLSnippet) RenderChildSnippet(childsnippet HTMLComposer) (_html HTMLString) {
// 	out := new(bytes.Buffer)
// 	id, err := WriteSnippet(out, _childsnippet, nil, true)
// 	if err == nil {
// 		_parent.Embed(id, _childsnippet) // need to embed the snippet itself
// 		_html = HTMLString(out.String())
// 	}
// 	return _html
// }

// WriteChildSnippet writes the HTML string of the composer, its tag element and its body, to the writer.
// The body is unfolded to look for sub-snippet and ever sub-snippet are also written to the writer.
// If the child request an ID, WriteChildSnippet generates an ID by prefixing its parent id.
// In addition the child is appended into the list of sub-components.
func (parent *HTMLSnippet) WriteChildSnippet(out io.Writer, childsnippet HTMLComposer) {
	id, err := WriteSnippet(out, childsnippet, nil, true)
	if err == nil {
		parent.Embed(id, childsnippet) // need to embed the snippet itself
	}
}

// WriteChildSnippet writes the HTML string of the composer, its tag element and its body, to the writer, only if the condition is true, otherwise does nothing.
// The body is unfolded to look for sub-snippet and ever sub-snippet are also written to the writer.
// If the child request an ID, WriteChildSnippet generates an ID by prefixing its parent id.
// In addition the child is appended into the list of sub-components.
func (parent *HTMLSnippet) WriteChildSnippetIf(condition bool, out io.Writer, childsnippet HTMLComposer) {
	if !condition {
		return
	}
	parent.WriteChildSnippet(out, childsnippet)
}

/******************************************************************************
* Classes
******************************************************************************/

// Classes returns the class attribute
func (_snippet *HTMLSnippet) Classes() string {
	_snippet.makemap()
	str := _snippet.attrs["03class"]
	return string(str)
}

// Classes returns the class attribute
func (_snippet *HTMLSnippet) HasClass(class string) bool {
	class = strings.Trim(class, " ")
	if class == "" {
		return false
	}
	_snippet.makemap()
	actual := _snippet.attrs["03class"]
	actualf := strings.Fields(string(actual))
	for _, actualc := range actualf {
		if actualc == class {
			return true
		}
	}
	return false
}

// ResetClasses replaces any existing classes with _clist to the class attribute
// _clist must contains strings separated by spaces.
// All classes are removed if _clist is empty.
// TODO: check validity of the class name pattern
func (_snippet *HTMLSnippet) ResetClasses(list string) {
	_snippet.makemap()
	n := ""
	f := strings.Fields(list)
	for _, c := range f {
		if c != "" {
			n += c + " "
		}
	}
	n = strings.TrimRight(n, " ")
	if n == "" {
		delete(_snippet.attrs, "03class")
	} else {
		_snippet.attrs["03class"] = n
	}
}

// SetClasses adds the _list of classes to the class attribute
// duplicate are not inserted twice.
// TODO: check validity of the class name pattern
func (_snippet *HTMLSnippet) SetClasses(list string) {
	_snippet.makemap()
	actual := _snippet.attrs["03class"]
	new := string(actual)
	actualf := strings.Fields(string(actual))
	listf := strings.Fields(list)
nextf:
	for _, listc := range listf {
		if listc != "" {
			for _, actualc := range actualf {
				if actualc == listc {
					continue nextf
				}
			}
			new += " " + listc
		}
	}
	new = strings.TrimLeft(new, " ")
	if new != "" {
		_snippet.attrs["03class"] = new
	}
}

// SetClassesIf SetClasses if the _condition is true
func (_snippet *HTMLSnippet) SetClassesIf(condition bool, list string) {
	if condition {
		_snippet.SetClasses(list)
	}
}

// RemoveClasses removes any class in _list from the "class" attribute.
// Does nothing if c did not exist.
func (_snippet *HTMLSnippet) RemoveClasses(list string) {
	_snippet.makemap()
	actual := _snippet.attrs["03class"]
	new := ""
	actualf := strings.Fields(string(actual))
	listf := strings.Fields(string(list))
nexta:
	for _, actualc := range actualf {
		for _, listc := range listf {
			if actualc == listc {
				continue nexta
			}
		}
		new += " " + actualc
	}
	new = strings.TrimRight(new, " ")
	_snippet.attrs["03class"] = new

}

// SwitchClasses removes _remove classes and set the _new one
// Does nothing if c did not exist.
func (_snippet *HTMLSnippet) SwitchClasses(removeclass string, newclass string) {
	_snippet.RemoveClasses(removeclass)
	_snippet.SetClasses(newclass)
}

/******************************************************************************
* Attributes
******************************************************************************/

// Attributes returns the formated list of attributes used to generate the container element.
// always sorted the same way : 1.id 2.tabindex 3.class 4.style 5. other-alpha
func (_snippet *HTMLSnippet) Attributes() string {
	_snippet.makemap()
	if len(_snippet.attrs) == 0 {
		return ""
	}

	strhtml := ""
	sorted := make([]string, 0, len(_snippet.attrs))
	for k := range _snippet.attrs {
		sorted = append(sorted, k)
	}
	sort.Strings(sorted)
	for _, kx := range sorted {
		v := _snippet.attrs[kx]
		k := kx[2:]
		strhtml += k
		sv := stringifyValue(string(v))
		if len(sv) > 0 {
			strhtml += "=" + sv
		}
		strhtml += " "
	}
	strhtml = strings.TrimRight(strhtml, " ")
	return strhtml
}

// stringifyValue returns an empty string if v is empty or if v == "false".
// stringifyValue returns an unquoted string if v can be converted in float.
// stringifyValue returns a quoted value, choosing the right quote, in other cases.
func stringifyValue(_val string) string {
	tv := strings.Trim(_val, " ")
	lv := strings.ToLower(tv)
	if len(tv) == 0 || lv == "false" {
		return ""
	}

	if lv == "true" {
		return lv
	}

	_, err := strconv.ParseFloat(tv, 64)
	if err == nil {
		return tv
	}

	var delim string
	if strings.ContainsRune(tv, rune('"')) {
		delim = "'"
	} else {
		delim = "\""
	}
	return delim + _val + delim

}

// Attribute returns the value of the attribute identified by _key.
// Returns false if the attribute does not exist.
func (_snippet *HTMLSnippet) Attribute(_key string) (string, bool) {
	_key = strings.Trim(_key, " ")
	v, found := _snippet.attrs["05"+_key]
	return string(v), found
}

// CreateAttribute create an attribute and set its value.
// If the attribute already exists nothing is done. Use SetAttribute if you want to create OR update an attribute.
// func (_snippet *HTMLSnippet) CreateAttribute(_key string, _value any) HTMLComposer {
// 	err := _snippet.setAttribute(_key, _value, false)
// 	if err != nil {
// 		fmt.Println("CreateAttribute fails:", err)
// 	}
// 	return _snippet
// }

// SetAttribute create an attribute and set its value.
// update indicates if an existing attribute must be updated or not.
func (_snippet *HTMLSnippet) SetAttribute(_key string, _value any, update bool) {
	err := _snippet.setAttribute(_key, _value, update)
	if err != nil {
		fmt.Println("SetAttribute fails:", err)
	}
}

// SetAttributeIf SetAttribute if the condition is true.
// update indicates if an existing attribute must be updated or not.
func (_snippet *HTMLSnippet) SetAttributeIf(condition bool, key string, value any, update bool) *HTMLSnippet {
	if condition {
		_snippet.SetAttribute(key, value, update)
	}
	return _snippet
}

func (_snippet *HTMLSnippet) setAttribute(key string, value any, overwrite bool) error {
	_snippet.makemap()
	key = strings.Trim(key, " ")
	switch strings.ToLower(key) {
	case "id":
		_, found := _snippet.attrs["01id"]
		if !found || overwrite {
			switch v := value.(type) {
			case string:
				if v == "" {
					delete(_snippet.attrs, "01id")
				} else {
					_snippet.SetId(v)
				}
			case HTMLString:
				if v == "" {
					delete(_snippet.attrs, "01id")
				} else {
					_snippet.SetId(string(v))
				}
			default:
				return errors.New("wrong value type for id")
			}
		}
	case "tabindex":
		_, found := _snippet.attrs["02tabIndex"]
		if !found || overwrite {
			switch v := value.(type) {
			case string:
				idx, _ := strconv.Atoi(string(v))
				_snippet.SetTabIndex(idx)
			case HTMLString:
				idx, _ := strconv.Atoi(string(v))
				_snippet.SetTabIndex(idx)
			case int:
				_snippet.SetTabIndex(v)
			case uint:
				_snippet.SetTabIndex(int(v))
			case float32:
				_snippet.SetTabIndex(int(v))
			case float64:
				_snippet.SetTabIndex(int(v))
			default:
				return errors.New("wrong value type for tabindex")
			}
		}
	case "class":
		var lst string
		switch v := value.(type) {
		case string:
			lst = v
		case HTMLString:
			lst = string(v)
		default:
			return errors.New("wrong value type for class")
		}
		if overwrite {
			_snippet.ResetClasses(lst)
		} else if value != "" {
			_snippet.SetClasses(lst)
		}
	case "style":
		// TODO: handle style update to not overwrite
		_, found := _snippet.attrs["04style"]
		if !found || overwrite {
			var style HTMLString
			switch v := value.(type) {
			case string:
				style = HTMLString(v)
			case HTMLString:
				style = v
			default:
				return errors.New("wrong value type for class")
			}
			_snippet.SetStyle(style)
		}
	default:
		_, found := _snippet.attrs["05"+key]
		if !found || overwrite {
			var strv string
			switch v := value.(type) {
			case string:
				strv = v
			case HTMLString:
				strv = string(v)
			case bool:
				if v {
					strv = ""
				} else {
					delete(_snippet.attrs, "05"+key)
					break
				}
			case int, uint, float32, float64:
				strv = fmt.Sprintf("%v", v)
			default:
				return errors.New("wrong value type for " + key)
			}
			_snippet.attrs["05"+key] = strv
		}
	}
	return nil
}

// RemoveAttribute remove the the attribute identified by _key.
// Does nothing if the _key is not found.
func (_snippet *HTMLSnippet) RemoveAttribute(_key string) {
	_snippet.makemap()
	_key = strings.Trim(_key, " ")
	switch strings.ToLower(_key) {
	case "id":
		delete(_snippet.attrs, "01id")
	case "tabindex":
		delete(_snippet.attrs, "02tabIndex")
	case "class":
		delete(_snippet.attrs, "03class")
	case "style":
		delete(_snippet.attrs, "04style")
	default:
		delete(_snippet.attrs, "05"+_key)
	}
}

// ToggleAttribute toggles the boolean attribute _key. Sets it when unsetted, and unset whrn setted.
func (_snippet *HTMLSnippet) ToggleAttribute(_key string) {
	_snippet.makemap()
	_key = strings.Trim(_key, " ")
	_, found := _snippet.attrs["05"+_key]
	if !found {
		_snippet.attrs["05"+_key] = ""
	} else {
		delete(_snippet.attrs, "05"+_key)
	}
}

/******************************************************************************
* Special Attributes
******************************************************************************/

// TabIndex returns the TabIndex attribute
func (_snippet *HTMLSnippet) TabIndex() int {
	_snippet.makemap()
	sidx := _snippet.attrs["02tabIndex"]
	idx, _ := strconv.Atoi(string(sidx))
	return idx
}

func (_snippet *HTMLSnippet) SetTabIndex(idx int) *HTMLSnippet {
	_snippet.makemap()
	_snippet.attrs["02tabIndex"] = strconv.Itoa(idx)
	return _snippet
}

// IsDisabled returns the boolean attribute
func (_snippet *HTMLSnippet) IsDisabled() bool {
	_snippet.makemap()
	str, found := _snippet.attrs["05disabled"]
	if !found || strings.ToLower(string(str)) == "false" || str == "0" {
		return false
	}
	return true
}

func (_snippet *HTMLSnippet) SetDisabled(_f bool) *HTMLSnippet {
	_snippet.makemap()
	if _f {
		_snippet.attrs["05disabled"] = ""
	} else {
		delete(_snippet.attrs, "05disabled")
	}
	return _snippet
}

/******************************************************************************
* Style
******************************************************************************/

// Style returns the style attribute
func (_snippet *HTMLSnippet) Style() string {
	_snippet.makemap()
	str := _snippet.attrs["04style"]
	return string(str)
}

// TODO: check style validity
func (_snippet *HTMLSnippet) SetStyle(style HTMLString) {
	_snippet.makemap()
	_snippet.attrs["04style"] = string(style)
}

// Template returns a SnippetTemplate used to render the html string of a Snippet.
// By default it returns any already setup _snippet properties.
// If overloaded,
// It's used by WriteSnippet, Unfold, RenderSnippet.
// func (_snippet HTMLSnippet) Template(*DataState) (_t SnippetTemplate) {
// 	_t.Tag = _snippet.Tag
// 	_t.Body = _snippet.Body
// 	_t.Attributes = _snippet.Attributes()
// 	return
// }
