package html

import (
	"io"
	"reflect"
	"strconv"
	"strings"

	"github.com/icecake-framework/icecake/pkg/registry"
	"github.com/lolorenzo777/verbose"
)

// maxDEEP is the maximum HTML string unfolding levels
const maxDEEP int = 25

type ComposerMap map[string]HTMLContentComposer

// RMetaData is rendering metadata for a single HTMLContentComposer
type RMetaData struct {
	VirtualId string        // virtual id allocated to an HTMLContentComposer, always one
	Id        string        // the id allocated to the HTMLContentComposer if any
	Parent    RMetaProvider // optional parent, may be an orphan
	Deep      int           // deepness of the HTMLContentComposer
	IsRender  bool          // Indicates the HTMLContentComposer has been rendered at least once
	RError    error         // rendering error if any
	IsMounted bool          // Indicates the HTMLContentComposer has been mounted

	childs ComposerMap // embedded child content composer
}

// func (rmeta *RMetaData) LinkParent(parent HTMLContentComposer) (deep int) {
// 	rmeta.Parent = parent
// 	rmeta.Deep = 0
// 	if parent != nil {
// 		rmeta.Deep = parent.RMeta().Deep + 1
// 	}
// 	return rmeta.Deep
// }

func (rmeta *RMetaData) RMeta() *RMetaData {
	return rmeta
}

// GenerateVirtualId generates a unique id for every rendering composer.
// The composer may not have a TagBuilder, so the Id is not necessarly the id attribute of the composer. The generated id pattern is:
//
//	`{{{parentid|orphan}.[cmpname.index]}|[cmpid]}`
//
// rules:
//   - if the rendering has a rendering parent, the virtual id starts with the parent's virtualid otherwise it's "orphan" followed by the component name
//   - if the rendering does not have a rendering parent, the virtual id is the given cmpid if not empty, otherwise it's "orphan"
//   - the dot "-" seperator is added followed by the cmpname if any
//
// - the cmpname is added
func (rmeta *RMetaData) GenerateVirtualId(cmp HTMLContentComposer) string {
	prefix := "orphan"
	if rmeta.Parent != nil {
		if pvid := rmeta.Parent.RMeta().VirtualId; pvid != "" {
			prefix = pvid
		}
	}
	prefix += "."
	toporphan := strings.HasPrefix(prefix, "orphan.")

	cmpname := reflect.TypeOf(cmp).Elem().Name()
	cmpname = strings.ToLower(cmpname)

	body := cmpname
	cmpid := cmp.RMeta().Id
	if cmpid != "" {
		body = cmpid
		if toporphan {
			toporphan = false
			prefix = ""
		}
	}

	index := 0
	if rmeta.Parent != nil {
		index = len(rmeta.Parent.RMeta().Embedded())
	} else {
		index, _ = registry.GetUniqueId(cmpname)
	}

	suffix := ""
	if cmpid == "" || toporphan {
		suffix = strconv.Itoa(index)
	}

	rmeta.VirtualId = prefix + body + suffix
	return rmeta.VirtualId
}

// Embed adds child to the map of embedded components.
// If a child with the same key has already been embedded it's replaced and a warning is raised in verbose mode.
// The key is the id of the html element if any otherwise it's its virtual id.
func (rmeta *RMetaData) Embed(child HTMLContentComposer) {
	if rmeta.childs == nil {
		rmeta.childs = make(ComposerMap, 1)
	}
	key := child.RMeta().Id
	if key == "" {
		key = child.RMeta().VirtualId
	}
	if _, f := rmeta.childs[key]; f {
		verbose.Println(verbose.WARNING, "Embed: duplicate child id:%q for parent id:%q", key, rmeta.VirtualId)
	}
	rmeta.childs[key] = child
	child.RMeta().Parent = rmeta
	// verbose.Debug("embedded (%v) %q", reflect.TypeOf(subcmp).String(), id)
}

// Embedded returns the map of embedded components, keyed by their id.
func (rmeta RMetaData) Embedded() ComposerMap {
	if rmeta.childs == nil {
		rmeta.childs = make(ComposerMap, 0)
	}
	return rmeta.childs
}

type RMetaProvider interface {
	// Meta returns a reference to render meta data
	RMeta() *RMetaData
}

type HTMLContentComposer interface {

	// Meta returns a reference to render meta data
	RMetaProvider

	// RenderContent writes the HTML string corresponding to the content of the HTML element.
	// Return an error to stops the rendering process.
	RenderContent(out io.Writer) error
}

// HTMLComposer interface combines TagBuilder interfaces and HTMLContentComposer interfaces
type HTMLComposer interface {
	TagBuilder
	HTMLContentComposer
}

// Render renders the HTML string of the composers to out, including its tag element its properties and its content.
// Rendering the content can renders child-snippets recursively. This can be done maxDEEP times max to avoid infinite loop.
//
// If composer is a also a TagBuilder the output looks like this:
//
//	`<{tagname} id={xxx} name="{ick-tag}" [attributes]>[content]</tagname>`
//
// otherwise only the content is written.
//
// A snippet id can be setup up upfront (a) accessing any saved tag attribute within the snippet struct, or (b) within an html ick-tag attribute (for embedded snippet).
// Thes id will be lost if ther'e a parent, the snippet attributes will be overwritten with the unique id generated by the rendering process.
// Unique ids are generated by using the composer name (without "ick-" prefix) with a sequence number. sub-composer ids combine the id of the parent with the id of the sub-composer.
// if the component is not registered and so does't have a name, a global unique id is generated.
// This behaviour ensures that ids are uniques even for multiple instanciations of the same composer.
//
// snippet may have none id on request. noid snippet attribute must be set to true to render the composer without id.
// The special attribute noid can be defined within an ick-tag html or with attribute's methods.
//
// If the parent is not nil, the snippet is added to its embedded stack of sub-components.
//
// Returns rendering errors, typically with the writer, or if there's too many recursive rendering.
// TODO: avoid rendering infinite loop when cmp == parent
func Render(out io.Writer, parent RMetaProvider, cmps ...HTMLContentComposer) error {
	for _, cmp := range cmps {
		err := render(out, parent, cmp)
		if err != nil {
			return err
		}
	}
	return nil
}

func render(out io.Writer, parent RMetaProvider, cmp HTMLContentComposer) error {

	// nothing to render
	if cmp == nil || reflect.TypeOf(cmp).Kind() != reflect.Ptr || reflect.ValueOf(cmp).IsNil() {
		verbose.Printf(verbose.WARNING, "Render: empty composer %s\n", reflect.TypeOf(cmp).String())
		return nil
	}

	// look for depth and ensure no infinite loop
	deep := 0
	if parent != nil {
		if deep = parent.RMeta().Deep + 1; deep > maxDEEP {
			return verbose.Error("Render", ErrTooManyRecursiveRendering)
		}
	}
	verbose.Printf(verbose.INFO, "rendering L.%v composer %s\n", deep, reflect.TypeOf(cmp).String())

	// build the tag
	var tag Tag
	cmptag, istagger := cmp.(TagBuilder)
	if istagger && cmptag != nil {
		tag = BuildTag(cmptag)
	}

	// generate the virtual id
	cmp.RMeta().GenerateVirtualId(cmp)

	// verbose id information
	//verbose.Debug(" vid:%s --> id:%s", virtualid, cmpid)

	// render openingtag
	if cmptag != nil {
		selfclosed, err := tag.RenderOpening(out)
		if selfclosed || err != nil {
			cmp.RMeta().RError = err
			return err
		}
	}

	// Render the content
	err := cmp.RenderContent(out)
	if err != nil {
		cmp.RMeta().RError = err
		return err
	}

	// Render closingtag
	if cmptag != nil {
		err := tag.RenderClosing(out)
		if err != nil {
			cmp.RMeta().RError = err
			return err
		}
	}

	// add it to the map of embedded components
	cmp.RMeta().IsRender = true
	cmp.RMeta().Deep = 0
	if parent != nil {
		parent.RMeta().Embed(cmp)
		cmp.RMeta().Deep = parent.RMeta().Deep + 1
	}

	return nil
}
